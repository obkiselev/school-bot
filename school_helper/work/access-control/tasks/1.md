---
status: planned                    # planned -> in_progress -> done
depends_on: []                     # no dependencies — wave 1
wave: 1
skills: [code-writing]
verify: bash — `python -c "from bot.db.database import get_db; from bot.db.queries import is_user_allowed, set_user_access, block_user, get_all_users_list; from bot.config import ADMIN_ID; print('OK')"`
reviewers: [code-reviewer, security-auditor, test-reviewer]
teammate_name:
---

# Task 1: Database migration and access queries

## Required Skills

Before starting, load:
- `/skill:code-writing` — [skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Add access-control columns (`role`, `is_blocked`) to the existing `users` table so the bot can distinguish admins from students and block users. Provide query functions that the rest of the access-control feature will use (is_user_allowed, set_user_access, block_user, get_all_users_list). Bootstrap the ADMIN_ID user as admin on every startup so the owner always has access. This is the foundation layer — all other access-control tasks depend on it.

## What to do

1. **`bot/config.py`** — Add `ADMIN_ID` variable loaded from env. Parse it as int. If empty or non-numeric, log a warning (use `logging.warning`) and set to `None`.

2. **`.env.example`** — Add `ADMIN_ID=` entry with a comment.

3. **`.env`** — Add `ADMIN_ID=` entry (leave value empty or set to the real admin ID if known).

4. **`bot/db/database.py`** — Add an idempotent migration step inside or after `_create_tables()`:
   - `ALTER TABLE users ADD COLUMN role TEXT DEFAULT 'student'` — catch the "duplicate column" error and ignore it.
   - `ALTER TABLE users ADD COLUMN is_blocked INTEGER DEFAULT 0` — same approach.
   - If `ADMIN_ID` is set (not None): bootstrap admin via `INSERT OR IGNORE INTO users (user_id, role, is_blocked) VALUES (?, 'admin', 0)` then `UPDATE users SET role = 'admin', is_blocked = 0 WHERE user_id = ?`.

5. **`bot/db/queries.py`** — Add four new async functions:
   - `is_user_allowed(user_id: int) -> tuple[bool, str | None]` — SELECT role, is_blocked FROM users WHERE user_id = ?. Return `(True, role)` if found and is_blocked=0. Return `(False, None)` if not found or is_blocked=1.
   - `set_user_access(user_id: int, role: str = 'student') -> None` — INSERT OR REPLACE user with given role and is_blocked=0. Preserve existing username/first_name if the user already exists (use INSERT ... ON CONFLICT DO UPDATE).
   - `block_user(user_id: int) -> bool` — UPDATE users SET is_blocked=1 WHERE user_id = ?. Return True if a row was updated, False if user not found.
   - `get_all_users_list() -> list[dict]` — SELECT user_id, first_name, username, role, is_blocked FROM users ORDER BY user_id.

## Acceptance Criteria

- [ ] `ADMIN_ID` loaded from env in `bot/config.py`; warning logged if missing/non-numeric
- [ ] `.env.example` contains `ADMIN_ID=` entry
- [ ] Migration adds `role` and `is_blocked` columns idempotently — multiple bot restarts cause no errors (TAC2)
- [ ] ADMIN_ID user is always set to role='admin', is_blocked=0 on every startup (TAC3)
- [ ] `is_user_allowed()` returns `(True, role)` for active users and `(False, None)` for missing/blocked users
- [ ] `set_user_access()` both sets role AND sets is_blocked=0 — effectively unblocks the user (TAC11)
- [ ] `block_user()` returns bool indicating whether the user existed
- [ ] `get_all_users_list()` returns list of dicts with user_id, first_name, username, role, is_blocked
- [ ] No new dependencies added to requirements.txt (TAC7)
- [ ] Verification command runs successfully: `python -c "from bot.db.database import get_db; from bot.db.queries import is_user_allowed, set_user_access, block_user, get_all_users_list; from bot.config import ADMIN_ID; print('OK')"`

## Context Files

- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)
- [decisions.md](../decisions.md)
- [bot/config.py](../../../bot/config.py) — current config with env loading
- [bot/db/database.py](../../../bot/db/database.py) — current DB singleton and _create_tables()
- [bot/db/queries.py](../../../bot/db/queries.py) — current query functions (ensure_user, save_test_session, etc.)
- [.env.example](../../../.env.example) — current env template

## Verification Steps

1. Run: `python -c "from bot.db.database import get_db; from bot.db.queries import is_user_allowed, set_user_access, block_user, get_all_users_list; from bot.config import ADMIN_ID; print('OK')"`
   - Expected: prints `OK` with no import errors.
2. Start the bot, check logs — no migration errors, no duplicate column warnings on second start.
3. Check the database: `sqlite3 data/school_helper.db ".schema users"` — should show role and is_blocked columns.
4. If ADMIN_ID is set, verify: `sqlite3 data/school_helper.db "SELECT user_id, role, is_blocked FROM users WHERE role='admin'"` — should show the admin row.

## Details

**Files to modify:**
- `bot/config.py` — add ADMIN_ID with int parsing and logging
- `bot/db/database.py` — add `_run_migrations()` called from `get_db()`, with ALTER TABLE and admin bootstrap
- `bot/db/queries.py` — add four new functions: is_user_allowed, set_user_access, block_user, get_all_users_list
- `.env.example` — add ADMIN_ID entry
- `.env` — add ADMIN_ID entry

**Dependencies:** None. This is wave 1 with no task dependencies.

**Edge cases:**
- ADMIN_ID env var is empty or not a number — must not crash, just warn
- ADMIN_ID env var is not set at all — same, warn and set to None
- Column already exists (repeat migration) — catch OperationalError, ignore
- `is_user_allowed()` called for a user_id not in the database — return (False, None)
- `block_user()` called for a user_id not in the database — return False
- `set_user_access()` called for a user_id not yet in users table — must INSERT the new row (not just UPDATE)

**Implementation hints:**
- SQLite raises `sqlite3.OperationalError: duplicate column name` when ALTER TABLE ADD COLUMN is called for an existing column. Catch this specific error.
- Use `cursor.rowcount` after UPDATE in `block_user()` to determine if the user existed.
- For `set_user_access()`, use INSERT ... ON CONFLICT(user_id) DO UPDATE to preserve existing username/first_name fields while setting role and is_blocked.
- Import `logging` in config.py; use `logging.getLogger(__name__)` pattern.
- The migration function should be called from `get_db()` after `_create_tables()`, so it runs once on first connection.

## Reviewers

- **code-reviewer** -> `logs/working/task-1/code-reviewer-{round}.json`
- **security-auditor** -> `logs/working/task-1/security-auditor-{round}.json`
- **test-reviewer** -> `logs/working/task-1/test-reviewer-{round}.json`

## Post-completion

- [ ] Record a brief summary in decisions.md (Summary: 1-3 sentences, review references with JSON links, no finding tables or dumps)
- [ ] If deviated from spec — describe the deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
