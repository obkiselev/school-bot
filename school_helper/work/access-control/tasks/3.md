---
status: planned                    # planned -> in_progress -> done
depends_on: [1]                    # requires DB queries and config from task 1
wave: 2
skills: [code-writing]
verify: bash — `python -c "from bot.handlers.admin import router; print('OK')"`
reviewers: [code-reviewer, security-auditor, test-reviewer]
teammate_name:
---

# Task 3: Admin command handlers

## Required Skills

Before starting, load:
- `/skill:code-writing` — [skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Create the admin router with three commands (`/allow`, `/block`, `/users`) that let admin-role users manage the whitelist. The handler validates all input (numeric user ID, role in allowed set), enforces protection rules (no self-block, no blocking ADMIN_ID, admin can block other admins), and responds with usage hints on bad format. Admin commands only work in private chats. This is the user-facing management interface for the access-control feature built on top of the DB queries from Task 1.

## What to do

1. **`bot/handlers/admin.py`** (new file) — Create an admin router with three command handlers:

   - `/allow <user_id> [role]` handler:
     - Parse command arguments from `message.text`. Split after the command to get user_id and optional role.
     - Validate user_id is numeric. If not — reply with usage hint including example.
     - Validate role is in `{'student', 'admin'}`. Default to `'student'` if not provided. If invalid role — reply with hint.
     - Check that the sender's role is `'admin'` (query DB with `is_user_allowed()`).
     - Check that `message.chat.type == 'private'`.
     - Call `set_user_access(user_id, role)` from `bot/db/queries.py`.
     - Respond: "Пользователь {user_id} добавлен (роль: {role})"

   - `/block <user_id>` handler:
     - Parse user_id from command arguments. Validate it is numeric.
     - Check sender is admin, chat is private (same as above).
     - Protection: if target user_id == sender's user_id — reply "Нельзя заблокировать самого себя".
     - Protection: if target user_id == ADMIN_ID from config — reply "Нельзя заблокировать главного администратора".
     - Call `block_user(user_id)`. If returns False (user not found) — reply accordingly.
     - Check if user is already blocked before calling block_user (query with `is_user_allowed()`). If already blocked — reply "Пользователь уже заблокирован".
     - Respond on success: "Пользователь {user_id} заблокирован"

   - `/users` handler:
     - Check sender is admin, chat is private.
     - Call `get_all_users_list()` from `bot/db/queries.py`.
     - Format a list showing: first_name (or user_id if no name), role, status (active/blocked).
     - Respond with the formatted list.

2. **`run.py`** — Import admin router and register it BEFORE other routers so admin commands are matched first:
   - Add `from bot.handlers import admin` to imports.
   - Add `dp.include_router(admin.router)` as the FIRST `include_router` call, before `start.router`.

## Acceptance Criteria

- [ ] TAC12: Admin input validation — user_id must be numeric, role must be in {'student', 'admin'}
- [ ] AC2: `/allow 123456789` adds user with role `student`
- [ ] AC3: `/allow 123456789 admin` adds user with role `admin`
- [ ] AC4: `/allow` for an existing user updates role and unblocks them
- [ ] AC5: `/block` blocks a user — they can finish a current test but cannot start a new one
- [ ] AC6: `/block` on an already-blocked user responds "Пользователь уже заблокирован"
- [ ] AC7: `/users` shows list with name, role, status
- [ ] AC8: `/allow`, `/block`, `/users` are only accessible to admin-role users
- [ ] AC9: Primary admin (ADMIN_ID) cannot be blocked
- [ ] AC10: Admin cannot block themselves
- [ ] AC11: Admin can block another admin
- [ ] AC12: Bad format input shows usage hint with example
- [ ] AC14: Admin commands only work in private chats
- [ ] TAC6: Admin router registered before other routers in dispatcher
- [ ] Verification command runs successfully: `python -c "from bot.handlers.admin import router; print('OK')"`

## Context Files

- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)
- [decisions.md](../decisions.md)
- [bot/handlers/start.py](../../../bot/handlers/start.py) — router pattern, handler signatures, imports
- [bot/db/queries.py](../../../bot/db/queries.py) — is_user_allowed, set_user_access, block_user, get_all_users_list (from Task 1)
- [bot/config.py](../../../bot/config.py) — ADMIN_ID variable (from Task 1)
- [run.py](../../../run.py) — dispatcher setup, router registration order

## Verification Steps

1. Run: `python -c "from bot.handlers.admin import router; print('OK')"`
   - Expected: prints `OK` with no import errors.
2. Open `run.py` and verify `admin.router` is included BEFORE `start.router`.
3. Manual Telegram test: send `/allow`, `/block`, `/users` from the admin account — verify responses match acceptance criteria.
4. Manual Telegram test: send `/allow abc` — verify usage hint is returned.
5. Manual Telegram test: send `/block <own_id>` — verify self-block is rejected.
6. Manual Telegram test: send admin commands from a group chat — verify they are ignored or rejected.

## Details

**Files to modify:**
- `bot/handlers/admin.py` (new) — admin router with /allow, /block, /users handlers
- `run.py` — import and register admin router before other routers

**Files to read:**
- `bot/handlers/start.py` — follow the same router/handler patterns (Router(), @router.message, Message type)
- `bot/db/queries.py` — use is_user_allowed(), set_user_access(), block_user(), get_all_users_list()
- `bot/config.py` — import ADMIN_ID for protection checks

**Dependencies:** Task 1 must be complete (provides ADMIN_ID in config, DB query functions in queries.py).

**Edge cases:**
- `/allow` with no arguments — show usage hint: "Формат: /allow <user_id> [student|admin]"
- `/allow` with non-numeric user_id (e.g., `/allow abc`) — show usage hint
- `/allow` with invalid role (e.g., `/allow 123 teacher`) — show hint listing valid roles
- `/block` with no arguments — show usage hint: "Формат: /block <user_id>"
- `/block` targeting self (sender's own user_id) — reject with "Нельзя заблокировать самого себя"
- `/block` targeting ADMIN_ID — reject with "Нельзя заблокировать главного администратора"
- `/block` targeting a user not in the database — report user not found
- `/block` targeting an already-blocked user — reply "Пользователь уже заблокирован"
- Admin commands sent in a group chat — ignore or reply "Команда доступна только в личных сообщениях"
- Non-admin user tries to send admin commands — ignore or deny access

**Implementation hints:**
- Follow the same pattern as `start.py`: `router = Router()`, `@router.message(Command("allow"))`, handler receives `Message`.
- Use `from aiogram.filters import Command` for matching /allow, /block, /users.
- Parse arguments with `message.text.split()` — index [0] is the command, [1] is user_id, [2] is optional role.
- For the admin-role check, call `is_user_allowed(message.from_user.id)` and verify `role == 'admin'`.
- For the private-chat check, use `message.chat.type == 'private'`. If not private, either return silently or send a brief message.
- For `/users` formatting, build a text string with one line per user. Use emoji indicators for status (e.g., active/blocked).
- Import `ADMIN_ID` from `bot.config` for the protection check in `/block`.

## Reviewers

- **code-reviewer** -> `logs/working/task-3/code-reviewer-{round}.json`
- **security-auditor** -> `logs/working/task-3/security-auditor-{round}.json`
- **test-reviewer** -> `logs/working/task-3/test-reviewer-{round}.json`

## Post-completion

- [ ] Record a brief summary in decisions.md (Summary: 1-3 sentences, review references with JSON links, no finding tables or dumps)
- [ ] If deviated from spec — describe the deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
