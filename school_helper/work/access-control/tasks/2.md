---
status: planned                    # planned -> in_progress -> done
depends_on: [1]                    # wave 1 must complete first (DB migration + queries)
wave: 2                            # wave of parallel execution
skills: [code-writing]             # skills to load
verify: bash                       # verification tool
reviewers: [code-reviewer, security-auditor, test-reviewer]
teammate_name:
---

# Task 2: Access control middleware

## Required Skills

Before starting, load:
- `/skill:code-writing` — [skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Create the `AccessControlMiddleware` — the central gate that decides whether an incoming Telegram update (message or callback button press) reaches a handler or gets blocked.

The middleware is registered as an **outer middleware** on the Dispatcher level, meaning it runs before any router or handler filter. Every `Message` and `CallbackQuery` passes through it. The logic:

1. **ADMIN_ID short-circuit** — if the user's Telegram ID matches `ADMIN_ID` from `.env`, always allow. This runs before any DB lookup, so the primary admin is never locked out even if the database is broken.
2. **DB lookup** — query `is_user_allowed(user_id)` to check if the user exists in the whitelist and is not blocked.
3. **User not found** — respond with "Доступ ограничен" and stop.
4. **User is blocked** — check FSM state. If the user is mid-quiz (`QuizFlow.answering_question` or `QuizFlow.answering_matching_sub`) and the action is quiz-related (`ans:*` callback or a text answer), allow it through so the user can finish the current test. Otherwise, block.
5. **DB failure** — fail-closed (block everyone except ADMIN_ID).
6. **Callback spinner** — for blocked `CallbackQuery` updates, call `callback.answer()` before returning to dismiss the Telegram loading spinner.

This task also wires the middleware into `run.py` (register on `dp.message.outer_middleware` and `dp.callback_query.outer_middleware`) and creates the `bot/middleware/` package.

## What to do

1. Create `bot/middleware/__init__.py` — empty file (or with a re-export of `AccessControlMiddleware`).
2. Create `bot/middleware/access.py` with `AccessControlMiddleware(BaseMiddleware)`:
   - Import `ADMIN_ID` from `bot.config`.
   - Import `is_user_allowed` from `bot.db.queries` (provided by Task 1).
   - Import `QuizFlow` from `bot.states.quiz_states`.
   - Implement `__call__(self, handler, event, data)` following the flow described above.
   - Extract `user_id` from `event.from_user.id` (works for both Message and CallbackQuery).
   - For ADMIN_ID check: compare `user_id == ADMIN_ID` before any DB call.
   - For DB lookup: wrap in try/except — on any exception, block (fail-closed), unless ADMIN_ID.
   - For blocked-but-mid-quiz check: get FSM context from `data["state"]`, call `await state.get_state()`, compare against `QuizFlow.answering_question` and `QuizFlow.answering_matching_sub`. For callbacks, check if `event.data` starts with `"ans:"`. For messages, allow plain text only (no commands).
   - For blocked/unknown users: send "❗ Доступ ограничен. Обратитесь к администратору." — for messages via `event.answer(...)`, for callbacks via `event.message.answer(...)` + `event.answer()`.
   - If allowed: `return await handler(event, data)`.
3. Modify `run.py`:
   - Import `AccessControlMiddleware` from `bot.middleware.access`.
   - Register it on `dp.message.outer_middleware(AccessControlMiddleware())` and `dp.callback_query.outer_middleware(AccessControlMiddleware())`.
   - Ensure middleware registration happens before `dp.include_router(...)` calls.
   - Ensure admin router (from Task 3) registration slot is before other routers — add a comment placeholder if Task 3 is not yet done.

## Acceptance Criteria

- [ ] TAC1: `AccessControlMiddleware` registered on both `dp.message` and `dp.callback_query` as outer middleware
- [ ] TAC4: Middleware checks FSM state before blocking — allows only quiz-related actions (`ans:*` callbacks, text answers in `answering_question`/`answering_matching_sub` state) for blocked users mid-test
- [ ] TAC5: `callback.answer()` called for blocked callback queries to dismiss spinner
- [ ] TAC6: Admin router registration slot exists before other routers in dispatcher
- [ ] TAC9: ADMIN_ID from `.env` is checked first in middleware (short-circuit, before DB query) — guarantees primary admin is never locked out
- [ ] TAC10: DB failure in middleware results in blocking (fail-closed), except for ADMIN_ID
- [ ] AC1: Unknown/unwhitelisted user sees "❗ Доступ ограничен. Обратитесь к администратору." on any action

## Context Files

- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)
- [decisions.md](../decisions.md)
- [architecture.md](~/.claude/skills/project-knowledge/architecture.md)
- [patterns.md](~/.claude/skills/project-knowledge/patterns.md)
- [project.md](~/.claude/skills/project-knowledge/project.md)
- `run.py` — current dispatcher setup, router registration order
- `bot/db/queries.py` — existing query patterns, `is_user_allowed()` (from Task 1)
- `bot/states/quiz_states.py` — `QuizFlow` states used for mid-quiz detection
- `bot/config.py` — `ADMIN_ID` env variable (from Task 1)

## Verification Steps

1. Run: `python -c "from bot.middleware.access import AccessControlMiddleware; print('OK')"`
   - Expected: prints `OK` with no import errors.
2. Check `run.py` registers middleware on both `dp.message.outer_middleware` and `dp.callback_query.outer_middleware`.
3. Check ADMIN_ID short-circuit is the first check in `__call__` (before any DB or try/except).
4. Check DB query is wrapped in try/except with fail-closed behavior.
5. Check `callback.answer()` is called for blocked CallbackQuery events.

## Details

**Files to create:**
- `bot/middleware/__init__.py` — package init, re-export `AccessControlMiddleware`
- `bot/middleware/access.py` — middleware class

**Files to modify:**
- `run.py` — register middleware on dispatcher, add admin router slot before other routers

**Files to read (for reference):**
- `run.py` — current structure (Bot, Dispatcher, router registration)
- `bot/db/queries.py` — `is_user_allowed()` signature: `async def is_user_allowed(user_id: int) -> tuple[bool, str | None]`
- `bot/states/quiz_states.py` — `QuizFlow` with `answering_question`, `answering_matching_sub` states
- `bot/config.py` — `ADMIN_ID: int | None` loaded from `.env`

**Dependencies:**
- Task 1 must be complete (provides `is_user_allowed` in queries.py and `ADMIN_ID` in config.py)
- No new packages needed — uses `aiogram.BaseMiddleware` (already installed)

**Edge cases:**
- `event.from_user` could be `None` for channel posts — block if no `from_user`
- ADMIN_ID could be `None` if not set in `.env` — skip the short-circuit check in that case (log warning, proceed to DB check)
- Blocked user mid-quiz sending a command (e.g., `/start`) — must be blocked, only plain text and `ans:*` callbacks are allowed
- `callback.answer()` must be called even when blocking to prevent Telegram spinner hanging

**Implementation hints:**
- aiogram outer middleware signature: `async def __call__(self, handler, event, data)`
- FSM state is available via `data["state"]` (type `FSMContext`), call `await state.get_state()` to get current state string
- Compare state with `QuizFlow.answering_question.state` and `QuizFlow.answering_matching_sub.state` (the `.state` property returns the string representation)
- For `CallbackQuery`, the text response goes to `event.message.answer(...)`, and `event.answer()` dismisses the spinner
- For `Message`, the text response goes to `event.answer(...)`

## Reviewers

- **code-reviewer** → `logs/working/task-2/code-reviewer-{round}.json`
- **security-auditor** → `logs/working/task-2/security-auditor-{round}.json`
- **test-reviewer** → `logs/working/task-2/test-reviewer-{round}.json`

## Post-completion

- [ ] Record a brief report in decisions.md following the template (Summary: 1-3 sentences, review links to JSONs, no finding tables or dumps)
- [ ] If deviated from spec — describe the deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
